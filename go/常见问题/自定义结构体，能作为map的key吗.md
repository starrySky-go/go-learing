# 1. 引言

在 Go 语言中，`map`是一种内置的数据类型，它提供了一种高效的方式来存储和检索数据。`map`是一种无序的键值对集合，其中每个键与一个值相关联。使用 map 数据结构可以快速地根据键找到对应的值，而无需遍历整个集合。

在 Go 语言中，`map` 是一种内置的数据类型，可以通过以下方式声明和初始化：

```go
m := make(map[keyType]valueType)
```

在使用`map`时，我们通常会使用基本数据类型作为键。然而，当我们需要将自定义的结构体作为键时，就需要考虑结构体中是否包含引用类型的字段。引用类型是指存储了数据的地址的类型，如指针、切片、字典和通道等。在`Go`中，引用类型具有动态的特性，可能会被修改或指向新的数据。这就引发了一个问题：能否将包含引用类型的自定义结构体作为`map`的键呢？

# 2. map的基本模型

了解能否将包含引用类型的自定义结构体作为`map`的键这个问题，我们需要先了解下`map`的基本模型。在Go语言中，`map`是使用哈希表实现的。哈希表是一种以键-值对形式存储数据的数据结构，它通过使用哈希函数将键映射到哈希值。

哈希函数是用于将键映射到哈希值的算法。它接受键作为输入并生成一个固定长度的哈希值。Go语言的 `map` 使用了内部的哈希函数来计算键的哈希值。

而不同的`key`通过哈希函数生成的哈希值可能是相同的，此时便发生了哈希冲突。哈希冲突指的是不同的键经过哈希函数计算后得到相同的哈希值。由于哈希函数的输出空间远远小于键的输入空间，哈希冲突是不可避免的。此时无法判断该`key`是当前哈希表中原本便已经存在的元素还是由于哈希冲突导致不同的键映射到同一个bucket。 此时便需要判断这两个`key`是否相等。

因此，在`map`中，作为`map`中的`key`，需要保证其支持对比操作的，能够比较两个`key`是否相等。

# 3. map 键的要求

从上面`map`基本的模型介绍中，我们了解到，`map`中的Key需要支持哈希函数的计算，同时键的类型必须支持对比操作。

在`map`中，计算`key`的哈希值，是由默认哈希函数实现的，对于`map`中的`key`并没有额外的要求。

在`map`中，判断两个键是否相等是通过调用键类型的相等运算符（`==`或`!=`）来完成的，因此`key`必须确保该类型支持 `==` 操作。这个要求是由 `map` 的实现机制决定的。`map` 内部使用键的相等性来确定键的存储位置和检索值。如果键的类型不可比较，就无法进行相等性比较，从而导致无法准确地定位键和检索值。

在 Go 中，基本数据类型（如整数、浮点数、字符串）和一些内置类型都是可比较的，因此它们可以直接用作 `map` 的键。然而，自定义的结构体作为键时，需要确保结构体的所有字段都是可比较的类型。如果结构体包含引用类型的字段，那么该结构体就不能直接用作 `map` 的键，因为引用类型不具备简单的相等性比较。

因此，假如`map`中的键为自定义类型，同时包含引用字段，此时将无法作为`map`的键，会直接编译失败，代码示例如下:

```go
type Person struct {
   Name    string
   Age     int
   address []Address
}
func main() {
    // 这里会直接编译不通过
    m := make(map[Person]int)
}
```

其次还有一个例外，那便是自定义结构体中包含指针类型的字段，此时其是支持`==`操作的，但是其是使用指针地址来进行`hash`计算以及相等性比较的，有可能我们理解是同一个`key`,事实上从`map`来看并不是，此时非常容易导致错误，示例如下:

```go
type Person struct {
   Name    string
   Age     int
   address *Address
}
func main(){
    m := make(map[Person]int)
    p1 := Person{Name: "Alice", Age: 30, address: &Address{city: "beijing"}}
    p2 := Person{Name: "Alice", Age: 30, address: &Address{city: "beijing"}}
    m[p1] = 1
    m[p2] = 2
    // 输出1
    fmt.Println(m[p1])
    // 输出2
    fmt.Println(m[p2])
}
```

这里我们定义了一个`Person`结构体，包含一个指针类型的字段`address`。创建了两个对象`p1`和`p2`,在我们的理解中，其是同一个对象，事实上在`map`中为两个两个互不相关的对象，主要原因都是使用地址来进行hash计算以及相等性比较的。

综上所述，如果自定义结构体中包含引用类型的字段(指针为特殊的引用类型)，此时将不能作为`map`类型的`key`。

# 4. 为什么不抽取hashCode和equals方法接口，由用户自行实现呢？

当前`go`中`map`中哈希值的计算，其提供了默认的哈希函数，不需要由用户去实现；其次`key`的相等性比较，是通过`==` 操作符来实现的，也不由用户自定义比较函数。那我们就有一个疑问了，为什么不抽取hashCode和equals方法接口，由用户来实现呢?

### 4.1 简单性和性能角度

相等性比较在 `Go` 语言中使用 `==` 操作符来实现，而哈希函数是由运行时库提供的默认实现。这种设计选择我理解可能基于以下几个原因:

1.  **简单性**：对于默认哈希函数函数来说，其内置在语言中的，无需用户额外的实现和配置。这简化了 map 的使用。对于相等性比较操作，`==` 操作符进行比较是一种直观且简单的方式。在语法上，`==` 操作符用于比较两个值是否相等，这种语法的简洁性使得代码更易读和理解。
2.  **性能**：默认的哈希函数是经过优化和测试的，能够在大多数情况下提供良好的性能。其次使用`==`来实现相等性比较，由于 `==` 操作符是语言层面的原生操作，编译器可以对其进行优化，从而提高代码的执行效率。

### 4.2 key不可变的限制

`map`键的不可变性也是一个考虑因素。基于`==`来判断对象是否相等，间接保证了键的不可变性。目前，`==`已经支持了大部分类型的比较，只有自定义结构体中的引用类型字段无法直接使用`==`进行比较。如果键中不存在引用类型字段，这意味着放入Map键的值在运行时不能发生变化，从而保证了键在运行时的不可变性。

如果`key`没有不可变的限制，那么之前存储在 `map` 中的键值对可能会出现问题。因为在放置元素时，`map` 会根据键的当前值计算哈希值，并使用哈希值来查找对应的存储位置。如果放在`map`中的键的值发生了变化，此时计算出来的`hash`值可能也发生变化，这意味数据放在了错误的位置。后续即使使用跟`map`中的键的同一个值去查找数据，也可能查找不到数据。

下面展示一个简单的代码，来说明可变类型作为`key`会导致的问题:

```go
type Person struct {
    Name       string
    Age        int
    SliceField []string
}

func main() {
    person := Person{Name: "Alice", Age: 25, SliceField: []string{"A", "B"}}
    // 假设Person可以作为键，事实上是不支持的
    personMap := make(map[Person]string)
    personMap[person] = "Value 1"

    // 修改person中SliceField的值
    person.SliceField[0] = "X"

    // 尝试通过相同的person查找值
    fmt.Println(personMap[person]) // 输出空字符串，找不到对应的值
}
```
如果抽取`equals`方法接口，由用户自行实现，此时`key`的不可变性就需要用户实现，其次`go`语言也需要增加一些检测机制，这首先增加了用户使用的负担，这并不符合`go`语言设计的哲学。

### 4.3 总结
综上所述，基于简单性、性能和语义一致性的考虑以及键的不可变性，Go语言选择使用`==`操作符进行键的比较，而将哈希函数作为运行时库的默认实现，更加符合`go`语言设计的哲学。

# 5. 总结
在 Go 语言中，map 是一种无序的键值对集合，它提供了高效的数据存储和检索机制。在使用 map 时，通常使用基本数据类型作为键。然而，当我们想要使用自定义结构体作为键时，需要考虑结构体中是否包含引用类型的字段。

自定义结构体作为`map`的键需要满足一些要求。首先，键的类型必须是可比较的，也就是支持通过`== `运算符进行相等性比较。在`Go`中，基本数据类型和一些内置类型都满足这个要求。但是，如果结构体中包含引用类型的字段，那么该结构体就不能直接作为`map`的键，因为引用类型不具备简单的相等性比较。

因此总的来说，包含引用类型字段的自定义结构体，是不能作为`map`的`key`的。
